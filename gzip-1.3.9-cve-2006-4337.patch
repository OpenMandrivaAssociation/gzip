diff -Naurp gzip-1.5/gzip.h gzip-1.5.oden/gzip.h
--- gzip-1.5/gzip.h	2012-06-20 16:36:18.000000000 +0200
+++ gzip-1.5.oden/gzip.h	2012-06-20 16:36:33.000000000 +0200
@@ -208,6 +208,8 @@ extern int save_orig_name; /* set if ori
 #define get_byte()  (inptr < insize ? inbuf[inptr++] : fill_inbuf(0))
 #define try_byte()  (inptr < insize ? inbuf[inptr++] : fill_inbuf(1))
 
+#define MIN(a,b) ((a) <= (b) ? (a) : (b)) 
+
 /* put_byte is used for the compressed output, put_ubyte for the
  * uncompressed output. However unlzw() uses window for its
  * suffix table instead of its output buffer, so it does not use put_ubyte
diff -Naurp gzip-1.5/unlzh.c gzip-1.5.oden/unlzh.c
--- gzip-1.5/unlzh.c	2012-06-20 16:36:18.000000000 +0200
+++ gzip-1.5.oden/unlzh.c	2012-06-20 16:36:33.000000000 +0200
@@ -150,8 +150,8 @@ local void make_table(nchar, bitlen, tab
     start[1] = 0;
     for (i = 1; i <= 16; i++)
         start[i + 1] = start[i] + (count[i] << (16 - i));
-    if ((start[17] & 0xffff) != 0)
-      gzip_error ("Bad table\n");
+    if ((start[17] & 0xffff) != 0 || tablebits > 16) /* 16 for weight below */
+      error("Bad table (case b)\n"); 
 
     jutbits = 16 - tablebits;
     for (i = 1; i <= (unsigned)tablebits; i++) {
@@ -165,15 +165,15 @@ local void make_table(nchar, bitlen, tab
 
     i = start[tablebits + 1] >> jutbits;
     if (i != 0) {
-        k = 1 << tablebits;
-        while (i != k) table[i++] = 0;
+        k = MIN(1 << tablebits, DIST_BUFSIZE);
+        while (i < k) table[i++] = 0;
     }
 
     avail = nchar;
     mask = (unsigned) 1 << (15 - tablebits);
     for (ch = 0; ch < (unsigned)nchar; ch++) {
         if ((len = bitlen[ch]) == 0) continue;
-        nextcode = start[len] + weight[len];
+	nextcode = MIN(start[len] + weight[len], DIST_BUFSIZE);
         if (len <= (unsigned)tablebits) {
             if ((unsigned) 1 << tablebits < nextcode)
               gzip_error ("Bad table\n");
@@ -216,7 +216,7 @@ local void read_pt_len(nn, nbit, i_speci
         for (i = 0; i < 256; i++) pt_table[i] = c;
     } else {
         i = 0;
-        while (i < n) {
+	while (i < MIN(n,NPT)) {
             c = bitbuf >> (BITBUFSIZ - 3);
             if (c == 7) {
                 mask = (unsigned) 1 << (BITBUFSIZ - 1 - 3);
@@ -228,7 +228,7 @@ local void read_pt_len(nn, nbit, i_speci
             pt_len[i++] = c;
             if (i == i_special) {
                 c = getbits(2);
-                while (--c >= 0) pt_len[i++] = 0;
+		while (--c >= 0 && i < NPT) pt_len[i++] = 0; 
             }
         }
         while (i < nn) pt_len[i++] = 0;
@@ -248,7 +248,7 @@ local void read_c_len()
         for (i = 0; i < 4096; i++) c_table[i] = c;
     } else {
         i = 0;
-        while (i < n) {
+	while (i < MIN(n,NC)) { 
             c = pt_table[bitbuf >> (BITBUFSIZ - 8)];
             if (c >= NT) {
                 mask = (unsigned) 1 << (BITBUFSIZ - 1 - 8);
@@ -263,7 +263,7 @@ local void read_c_len()
                 if      (c == 0) c = 1;
                 else if (c == 1) c = getbits(4) + 3;
                 else             c = getbits(CBIT) + 20;
-                while (--c >= 0) c_len[i++] = 0;
+		while (--c >= 0 && i < NC) c_len[i++] = 0; 
             } else c_len[i++] = c - 2;
         }
         while (i < NC) c_len[i++] = 0;
@@ -356,7 +356,7 @@ local unsigned decode(count, buffer)
     while (--j >= 0) {
         buffer[r] = buffer[i];
         i = (i + 1) & (DICSIZ - 1);
-        if (++r == count) return r;
+	if (++r >= count) return r;
     }
     for ( ; ; ) {
         c = decode_c();
@@ -366,14 +366,14 @@ local unsigned decode(count, buffer)
         }
         if (c <= UCHAR_MAX) {
             buffer[r] = c;
-            if (++r == count) return r;
+	    if (++r >= count) return r;
         } else {
             j = c - (UCHAR_MAX + 1 - THRESHOLD);
             i = (r - decode_p() - 1) & (DICSIZ - 1);
             while (--j >= 0) {
                 buffer[r] = buffer[i];
                 i = (i + 1) & (DICSIZ - 1);
-                if (++r == count) return r;
+		if (++r >= count) return r;
             }
         }
     }
diff -Naurp gzip-1.5/unpack.c gzip-1.5.oden/unpack.c
--- gzip-1.5/unpack.c	2012-06-20 16:36:18.000000000 +0200
+++ gzip-1.5.oden/unpack.c	2012-06-20 16:36:33.000000000 +0200
@@ -21,9 +21,6 @@
 #include "tailor.h"
 #include "gzip.h"
 
-#define MIN(a,b) ((a) <= (b) ? (a) : (b))
-/* The arguments must not have side effects. */
-
 #define MAX_BITLEN 25
 /* Maximum length of Huffman codes. (Minor modifications to the code
  * would be needed to support 32 bits codes, but pack never generates
